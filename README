# xv6 启动链路实践
1.启动流程说明

本次实践基于 MIT xv6 的 x86 版本，主要目标是理解操作系统从 bootloader 到内核 main 函数的完整启动过程。启动过程从 bootasm.S 开始，BIOS 会把 bootblock 加载到物理地址 0x7c00 并开始执行。在这个阶段，程序会先设置段寄存器 DS、ES 和 SS，开启 A20 地址线，并切换到 32 位保护模式，同时初始化 GDT，最后调用 bootmain 函数进入 C 语言代码执行阶段。

在 bootmain.c 中，程序首先打印 “[BOOT] enter bootmain” 来标记进入 bootmain 函数，然后读取内核 ELF 文件的第一页数据，并验证 ELF 魔数是否正确，验证通过后打印 “[BOOT] elf header loaded”。随后程序会遍历 ELF 文件中的每个程序段，将其加载到对应的物理内存中，加载完成后打印 “[BOOT] kernel loaded”，最后跳转到 ELF 的入口地址。

进入 entry.S 后，CPU 会进行分页设置，包括开启 4MB 页扩展、加载页目录和开启分页功能，同时设置内核栈，最后跳转到 main 函数。在 main.c 中，内核完成了物理页分配器初始化、页表初始化、多核 CPU 的检测和启动、设备初始化以及内核数据结构的设置。此时，程序打印 “[KERNEL] main() started”，标志着内核 C 语言部分正式开始执行。之后内核会启动第一个用户进程，并进入调度器，CPU 开始执行进程调度。

通过这样的步骤，可以清晰地看到从 bootloader 到内核 main 的启动链路，汇编与 C 代码在启动阶段的协作方式，以及 ELF 内核镜像加载和页表初始化的流程。

2.运行结果

在 QEMU 模拟器中启动 xv6 后，可以看到完整的启动打印信息。首先会打印 bootmain 阶段的消息，包括 “[BOOT] enter bootmain”、“[BOOT] elf header loaded” 和 “[BOOT] kernel loaded”，紧接着进入内核后打印 “[KERNEL] main() started”，随后各个 CPU 启动信息也会显示出来，例如 “cpu0: starting 0”、“cpu1: starting 1”等等。通过这些信息，可以直观地了解系统启动的顺序以及每个阶段的执行情况。

3.个人总结

通过本次实践，我对 xv6 的启动链路有了系统的理解，从 bootloader、汇编代码到内核 C 代码的执行顺序都非常清晰。实验中加入启动打印信息，让我能够直观地看到每一步的执行效果，加深了对内核镜像加载、页表初始化和多核 CPU 启动机制的理解。在这个过程中，我也练习了如何在汇编和 C 代码中安全地添加调试输出，并熟悉了 Git 的 fork、commit 和 push 流程，为后续进行操作系统实验和内核开发打下了基础。整个实践不仅提升了对操作系统底层原理的理解，也增强了动手能力和调试思维。
